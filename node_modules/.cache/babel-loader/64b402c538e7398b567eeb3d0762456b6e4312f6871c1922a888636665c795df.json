{"ast":null,"code":"// Inspiration: https://github.com/facebook/react/issues/3386\n\nfunction replace(string, regexpOrSubstr, newValueOrFn, globalOffset) {\n  if (typeof string !== 'string') throw new Error('First param must be a string');\n  if (typeof regexpOrSubstr !== 'string' && !(regexpOrSubstr instanceof RegExp)) throw new Error('Second param must be a string pattern or a regular expression');\n  var fn = typeof regexpOrSubstr === 'string' ? replaceUsingString : replaceUsingRegexp;\n  return fn(string, regexpOrSubstr, newValueOrFn, globalOffset);\n}\nfunction replaceUsingString(string, patternString, newValueOrFn, globalOffset) {\n  var index = string.indexOf(patternString);\n  if (index >= 0) {\n    var arr = [];\n    var endIndex = index + patternString.length;\n    if (index > 0) {\n      arr.push(string.substring(0, index));\n    }\n    arr.push(typeof newValueOrFn === 'function' ? newValueOrFn(string.substring(index, endIndex), index + globalOffset, string) : newValueOrFn);\n    if (endIndex < string.length) {\n      arr.push(string.substring(endIndex));\n    }\n    return arr;\n  } else {\n    return [string];\n  }\n}\nfunction replaceUsingRegexp(string, regexp, newValueOrFn, globalOffset) {\n  var output = [];\n  var replacerIsFn = typeof newValueOrFn === 'function';\n  var storedLastIndex = regexp.lastIndex;\n  regexp.lastIndex = 0;\n  var result;\n  var lastIndex = 0;\n  while (result = regexp.exec(string)) {\n    var index = result.index;\n    if (result[0] === '') {\n      // When the regexp is an empty string\n      // we still want to advance our cursor to the next item.\n      // This is the behavior of String.replace.\n      regexp.lastIndex++;\n    }\n    if (index !== lastIndex) {\n      output.push(string.substring(lastIndex, index));\n    }\n    var match = result[0];\n    lastIndex = index + match.length;\n    var out = replacerIsFn ? newValueOrFn.apply(this, result.concat(index + globalOffset, result.input)) : newValueOrFn;\n    output.push(out);\n    if (!regexp.global) {\n      break;\n    }\n  }\n  if (lastIndex < string.length) {\n    output.push(string.substring(lastIndex));\n  }\n  regexp.lastIndex = storedLastIndex;\n  return output;\n}\nmodule.exports = function stringReplaceToArray(stringOrArray, regexpOrSubstr, newSubStrOrFn) {\n  if (typeof stringOrArray === 'string') {\n    return replace(stringOrArray, regexpOrSubstr, newSubStrOrFn, 0);\n  } else if (!Array.isArray(stringOrArray) || !stringOrArray[0]) {\n    throw new TypeError('First argument must be an array or non-empty string');\n  } else {\n    var len = stringOrArray.length;\n    var output = [];\n    var globalOffset = 0;\n    for (var i = 0; i < len; ++i) {\n      var arrayItem = stringOrArray[i];\n      if (typeof arrayItem === 'string') {\n        output.push.apply(output, replace(arrayItem, regexpOrSubstr, newSubStrOrFn, globalOffset));\n        globalOffset += arrayItem.length;\n      } else {\n        output.push(arrayItem);\n      }\n    }\n    return output;\n  }\n};","map":{"version":3,"names":["replace","string","regexpOrSubstr","newValueOrFn","globalOffset","Error","RegExp","fn","replaceUsingString","replaceUsingRegexp","patternString","index","indexOf","arr","endIndex","length","push","substring","regexp","output","replacerIsFn","storedLastIndex","lastIndex","result","exec","match","out","apply","concat","input","global","module","exports","stringReplaceToArray","stringOrArray","newSubStrOrFn","Array","isArray","TypeError","len","i","arrayItem"],"sources":["C:/Users/Admin/OneDrive - The Chinese University of Hong Kong/github/kg571852741.github.io/node_modules/string-replace-to-array/string-replace-to-array.js"],"sourcesContent":["// Inspiration: https://github.com/facebook/react/issues/3386\n\nfunction replace (string, regexpOrSubstr, newValueOrFn, globalOffset) {\n\tif (typeof string !== 'string') throw new Error('First param must be a string')\n\tif (typeof regexpOrSubstr !== 'string' && !(regexpOrSubstr instanceof RegExp)) throw new Error('Second param must be a string pattern or a regular expression')\n\n\tvar fn = (typeof regexpOrSubstr === 'string') ? replaceUsingString : replaceUsingRegexp\n\n\treturn fn(string, regexpOrSubstr, newValueOrFn, globalOffset)\n}\n\nfunction replaceUsingString (string, patternString, newValueOrFn, globalOffset) {\n\tvar index = string.indexOf(patternString)\n\n\tif (index >= 0) {\n\t\tvar arr = []\n\t\tvar endIndex = index + patternString.length\n\n\t\tif (index > 0) {\n\t\t\tarr.push(string.substring(0, index))\n\t\t}\n\n\t\tarr.push(\n\t\t\t(typeof newValueOrFn === 'function') ?\n\t\t\t\tnewValueOrFn(\n\t\t\t\t\tstring.substring(index, endIndex),\n\t\t\t\t\tindex + globalOffset,\n\t\t\t\t\tstring\n\t\t\t\t) :\n\t\t\t\tnewValueOrFn\n\t\t)\n\n\t\tif (endIndex < string.length) {\n\t\t\tarr.push(string.substring(endIndex))\n\t\t}\n\n\t\treturn arr\n\t} else {\n\t\treturn [string]\n\t}\n}\n\nfunction replaceUsingRegexp (string, regexp, newValueOrFn, globalOffset) {\n\tvar output = []\n\n\tvar replacerIsFn = (typeof newValueOrFn === 'function')\n\n\tvar storedLastIndex = regexp.lastIndex\n\tregexp.lastIndex = 0\n\n\tvar result\n\tvar lastIndex = 0\n\twhile (result = regexp.exec(string)) {\n\t\tvar index = result.index\n\n\t\tif (result[0] === '') {\n\t\t\t// When the regexp is an empty string\n\t\t\t// we still want to advance our cursor to the next item.\n\t\t\t// This is the behavior of String.replace.\n\t\t\tregexp.lastIndex++\n\t\t}\n\n\t\tif (index !== lastIndex) {\n\t\t\toutput.push(string.substring(lastIndex, index))\n\t\t}\n\n\t\tvar match = result[0]\n\t\tlastIndex = index + match.length\n\t\t\n\t\tvar out = replacerIsFn ?\n\t\t\tnewValueOrFn.apply(this, result.concat(index + globalOffset, result.input)) :\n\t\t\tnewValueOrFn\n\t\toutput.push(out)\n\n\t\tif (!regexp.global) {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (lastIndex < string.length) {\n\t\toutput.push(string.substring(lastIndex))\n\t}\n\n\tregexp.lastIndex = storedLastIndex\n\treturn output\n}\n\nmodule.exports = function stringReplaceToArray (stringOrArray, regexpOrSubstr, newSubStrOrFn) {\n\tif (typeof stringOrArray === 'string') {\n\t\treturn replace(stringOrArray, regexpOrSubstr, newSubStrOrFn, 0)\n\t} else if (!Array.isArray(stringOrArray) || !stringOrArray[0]) {\n\t\tthrow new TypeError('First argument must be an array or non-empty string')\n\t} else {\n\t\tvar len = stringOrArray.length\n\t\tvar output = []\n\t\tvar globalOffset = 0\n\t\tfor (var i = 0; i < len; ++i) {\n\t\t\tvar arrayItem = stringOrArray[i]\n\t\t\tif (typeof arrayItem === 'string') {\n\t\t\t\toutput.push.apply(output, replace(arrayItem, regexpOrSubstr, newSubStrOrFn, globalOffset))\n\t\t\t\tglobalOffset += arrayItem.length\n\t\t\t} else {\n\t\t\t\toutput.push(arrayItem)\n\t\t\t}\n\t\t}\n\t\treturn output\n\t}\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}